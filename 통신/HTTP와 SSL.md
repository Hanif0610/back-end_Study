# HTTP와 SSL 통신 과정
## HTTP와 HTTPS
- HTTP는 HyperText Transfer Protocal의 약자로 HyperText인 html에게 전송하기 위한 통신규약을 의미
- S는 Secure의 약자로 HTTP뒤에 s를 붙이는 것은 보안이 강화된 통신규약임을 나타냄
- HTTP는 암호화되지 않은 방법으로 데이터를 전송하기 때문에 서버와 클라이언트가 주고 받는 메시지를 감청하는 것이 매우 쉬움
- 따라서 로그인등과 같은 중요한 데이터를 서버로 전송할 경우에 HTTPS 프로토콜을 사용하여 통신하는 것이 중요함
## HTTPS와 SSL
- HTTPS는 SSL 프로토콜을 기반으로 돌아가는 **프로토콜** 중 하나이다.
## **SSL과 TSL**
- 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀜
- SSL과 TLS는 같은 뜻으로 말하며, TSLS1.0은 SSL3.0을 계승함
- 하지만, TLS라는 이름보단 SSL이라는 이름으로 더 많이 사용됨
## SSL이란?
- SSL인증서란 클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서
- 라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달
## **SSL를 사용할 때의 이점**
1. 통신 내용이 공격자에게 노출이 되는 것을 막을 수 있음
2. 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지 판단 가능
3. 통신 내용의 악의적인 변경을 방지할 수 있음
## SSL에서 사용하는 암호화의 종류
1. 대칭키
2. 공개키

## 대칭키
<U>암호를 만드는 행위인 **암호화**</U>를 할 때 사용하는 일종의 비밀번호를 키(key)라고 한다. 이 키에 따라서 암호화된 결과가 달라지기 때문에 키를 모르면 <U>암호를 푸는 행위인 **복호화**</U>를 할 수 없다. **대칭키는 동일한 키로 암호화와 복호화를 같이할 수 있는 방식의 암호화 기법**을 의미한다. (ex. 암호화할 때 1234라는 값을 사용했다면 복호화할 때 1234라는 값을 복호화가 완료된다.)

허나 대칭키 방식은 단점이 존재한다.\
암호를 주고 받는 사람들 사이에서 이 키(key)로 암호화하라고 사용자에게 전달하는 것이 어렵다. 이유는 **중간에 대칭키가 유출된다면 키를 획득한 공격자는 암호의 내용을 복호화하여 무슨 데이터를 전달하려 하는 것인지 알 수 있기에 HTTPS를 사용하는 이유가 없어진다.** 그래서 나온 방법이 바로 공개키 기법이다.
## 공개키
공개키 방식은 대칭키와는 다르게 **두 개의 키를 가지고 시작**한다. 이 두개의 키는 A키로 암호화를 하면 B키로 복호화 할 수 있고, B키로 암호화하면 A키로 복호화 할 수 있는 방식이다. 두 개의 키 중 하나를 **비공개키(private key, 개인키/비밀키)** 라고 부르며 다른 한 키를 **공개키(public key)** 라고 한다.

 비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공한다. 내가 발행한 공개키를 전달받은 타인은 공개키를 이용해 암호화하고, 암호화한 정보를 비공개키를 갖고 있는 나에게 다시 전달하면 비공개키를 이용해 복호화하여 정보를 확인할 수 있다.

 (ex. 클라이언트가 받은 키를 가지고 1234(정보)를 암호화하여 서버에게 !@#$라는 정보를 전달하면 서버에서는 받은 정보를 복호화하여 1234라는 것을 확인한다.)

 정리하면 정보와 공개키를 획득한 사람은 공개키를 통해 정보를 암호화 혹은 복호화를 한다. 이 과정에서 공개키가 유출된다 한들, 데이터를 보호하려는 목적이 아닌 서로의 신원을 확인하는 목적이기에 상관이 없다. 즉, 공개키가 데이터를 제공한 사람의 신원을 보장해주는 것이다.\
 이것을 **전자서명**이라고 부른다.
>전자 서명의 동작 방식

 ![](https://t1.daumcdn.net/cfile/tistory/2117354956E4E16F2B)

 ## **CA(Certificate Authority)**
 - 인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 한다.
 - 디지털 인증서를 제공하는 공인된 기업 (Certificate Authority 혹은 Root Certificate)
 - CA는 아무 기업이나 할 수 있는 것이 아니고 신뢰성이 엄격하게 공인된 기업들만이 참여가능하다.
- 대표적인 CA 서비스 제공 기업과 시장점유율
    -  Symantec (VeriSign, Thawte, Geotrust) with 42.9% market share
    - Comodo with 26%
    - GoDaddy with 14%
    - GlobalSign with 7.7%

## SSL 인증서 내용
- 서비스 정보(인증서를 발급한 CA, 서비스의 도메인 등등)
- 서버 측 공개키(공개키의 내용, 공개키의 암호화 방법)
## SSL 인증서가 서비스를 보증하는 방법
- 웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제공한다.
- 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트인지 확인한다.
- 리스트에 포함된 경우 해당 CA의 공개키를 이용해 인증서 복호화한다.
## SSL의 동작방법
- 공개키 암호 방식은 알고리즘 계산방식이 느린 경향이 존재한다.
- 공개키 암호화 방식과 공개키의 단점을 보완한 대칭키 암호화 방식을 함께 사용한다.
- 서버와 클라이언트가 주고받는 정보는 대칭키로 암호화한다.
- 암호화된 실제 정보를 복호화할 때 사용할 대칭키는 공개키 방식으로 암호화하여 클라이언트와 서버가 주고받는다.
    - 실제 데이터 암호화 방식 : 대칭키
    - 대칭키를 서로 공유하기 위한 암호화 방식(대칭키의 키): 공개키
## SSL의 통신과정
- 컴퓨터와 컴퓨터가 네트워크 통신을 할 때 `핸드쉐이크 -> 세션 -> 세션종료`의 과정을 거친다.
1. 핸드쉐이크
    - SSL 방식을 이용해서 통신을 하는 브라우저와 서버 역시 핸드쉐이크를 하는데, 이 때 SSL 인증서를 주고 받는다.
    - 핸드쉐이크 단계에서 클라이언트와 서버가 통신하는 과정
    1. Client Hello : 클라이언트가 서버에 접속
        - 클라이언트 측에서 생성한 랜덤 데이터를 서버로 전송한다.
        - 클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.
        - 세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.
    2. Server Hello :  Client Hello에 대한 응답으로 Server Hello를 하게 됨
        - 서버 측에서 생성한 랜덤 데이터를 클라이언트로 전송한다.
        - 서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환함
        - 서버가 클라이언트로 인증서 전달한다.
    3. 클라이언트는 서버가 보내준 인증서가 어떤 CA에 의해 발급된 것인지 확인하기 위해 클라이언트에 내장돼있는 CA리스트 확인한다.\
    CA리스트에 없는 인증서라면 사용자에게 경고 메시지 출력한다.\
    인증서가 CA에 의해  발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다.\
    복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임을 암시적으로 보증한 것이므로 인증서를 전송한 서버를 믿게 된다.

        클라이언트는 서버에서 전달받은 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합하여 pre master secret라는 키를 생성한다.\
        이 키는 뒤에 볼 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해서 사용된다.\
        이때 사용할 암호화 기법은 대칭키이므로 pre master secret 값은 제 3자에게 노출되면 안된다.

        이후 pre master secret 키를 다시 서버로 전송하는데, 이때 공개키 방식을 사용하여 전송한다.
    4. 서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화함\
    이로서 서버와 클라이언트가 모두 pre master secret 값을 공유하게 되었고, 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다.\
    master secret는 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다.
    5. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.
2. 세션
    - 세션은 실제로 서버와 클라이언트가 데이터를 주고 받는 단계이다.
    - 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화하고, 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화할 수 있다.
3. 세션종료
    - 데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.
![](https://t1.daumcdn.net/cfile/tistory/990B63335BC96D3020)